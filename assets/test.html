<!DOCTYPE html>
<body style="background: #f0f0f0">
  <button id="btn" style="position: relative; z-index: 1">do something</button>
  <pre id="app" style="font: 10px monospace"></pre>
  <canvas id="canvas" width="1600" height="800" style="position: fixed; top: 0; left: 0; opacity: 0.5"></canvas>
  <script>
    const app = document.getElementById("app")
    const btn = document.getElementById("btn")
    const canvas = document.getElementById("canvas")
    const ctx = canvas.getContext("2d")

    function dump(buffer) {
      let dump = ''
      for (let i = 0; i < 65_536; i++) {
        if (i % 64 === 0) dump += `\n${i.toString(16).padStart(5, '0')}:`
        dump += ` ${buffer[i].toString(16).padStart(2, '0')}`
      }
      app.textContent = dump
    }

    const cols = 128 / 4
    const rows = 64 / 4

    const a = 2 * Math.PI / 6
    const r = Math.min(canvas.height / (rows * Math.sin(a)), (canvas.width / cols) / (Math.cos(a) - Math.cos(3 * a)))

    function drawHexagon(x, y, fillStyle) {
      ctx.beginPath()
      for (var i = 0; i < 6; i++) {
        ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i))
      }
      ctx.closePath()
      ctx.fillStyle = fillStyle
      ctx.fill()
    }

    function render(buffer, page_size, cell_size, cols) {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      for (let i = 0; i < page_size; i += cell_size) {
        if (!buffer[i + 2] && !buffer[i + 1] && !buffer[i]) continue
        const x = ~~((i / cell_size) % cols)
        const y = ~~((i / cell_size) / cols)

        const fillStyle = `rgb(${buffer[i + 2]}, ${buffer[i + 1]}, ${buffer[i]})`
        drawHexagon(x * r * (1 + Math.cos(a)), y * 2 * r * Math.sin(a) - (-1) ** x * r * Math.sin(a) / 2, fillStyle)
      }
    }

    function update(instance) {
      const { page_size, cell_size, cols, memory, offset } = instance.exports
      const buffer = new Uint8Array(memory.buffer, offset.value, page_size.value)
      dump(buffer)
      render(buffer, page_size.value, cell_size.value, cols.value)
    }

    function init(instance) {
      const { cols, memory, offset, page_size, cell_size } = instance.exports

      let color = null
      let timeout = null
      canvas.addEventListener('click', (event) => {
        // brute force which potential hexagon center is closest ¯\_(ツ)_/¯
        const potentialXs = [], potentialYs = []
        potentialXs[0]= Math.floor(event.offsetX / (r * (1 + Math.cos(a))))
        potentialXs[1] = potentialXs[0] - 1
        potentialXs[2] = potentialXs[0] + 1

        potentialYs[0] = Math.floor(event.offsetY / (2 * r * Math.sin(a) - r * Math.sin(a) / 2))
        potentialYs[1] = potentialYs[0] - 1
        potentialYs[2] = potentialYs[0] + 1
        potentialYs[3] = Math.floor(event.offsetY / (2 * r * Math.sin(a) + r * Math.sin(a) / 2))
        potentialYs[4] = potentialYs[3] - 1
        potentialYs[5] = potentialYs[3] + 1

        let x, y, smallestDistanceSq = Infinity
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 6; j++) {
            const canvasX = potentialXs[i] * r * (1 + Math.cos(a))
            const canvasY = potentialYs[j] * 2 * r * Math.sin(a) - (-1) ** potentialXs[i] * r * Math.sin(a) / 2
            const distanceSq = (event.offsetX - canvasX) ** 2 + (event.offsetY - canvasY) ** 2
            if (distanceSq < smallestDistanceSq) {
              smallestDistanceSq = distanceSq
              x = potentialXs[i]
              y = potentialYs[j]
            }
          }
        }

        const buffer = new Uint8Array(memory.buffer, offset.value, page_size.value)
        const index = (y * cols.value + x) * cell_size.value

        clearTimeout(timeout)
        timeout = setTimeout(() => {
          color = null
        }, 1000)
        if (!color) {
          color = [~~(Math.random() * 255), ~~(Math.random() * 255), ~~(Math.random() * 255)]
        }

        if (!buffer[index + 2] && !buffer[index + 1] && !buffer[index]) {
          buffer[index + 2] = color[0]
          buffer[index + 1] = color[1]
          buffer[index] = color[2]
        } else {
          buffer[index + 2] = 0
          buffer[index + 1] = 0
          buffer[index] = 0
        }

        update(instance)
      })

      update(instance)
    }

    const imports = {
      console: { log: console.log },
    }

    WebAssembly.instantiateStreaming(fetch('/assets/build/game.wasm'), imports).then((obj) => {
      const { next_gen } = obj.instance.exports

      btn.onclick = () => {
        next_gen()
        update(obj.instance)
      }

      init(obj.instance)
    })
  </script>
</body>
